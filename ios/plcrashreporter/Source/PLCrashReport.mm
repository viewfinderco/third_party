/*
 * Author: Landon Fuller <landonf@plausiblelabs.com>
 *
 * Copyright (c) 2008-2010 Plausible Labs Cooperative, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#import "PLCrashReport.h"
#import "CrashReporter.h"

#import "crash_report.pb.h"

struct _PLCrashReportDecoder {
    plcrash::CrashReport *crashReport;
};

#define IMAGE_UUID_DIGEST_LEN 16

@interface PLCrashReport (PrivateMethods)

- (plcrash::CrashReport *) decodeCrashData: (NSData *) data error: (NSError **) outError;
- (PLCrashReportSystemInfo *) extractSystemInfo: (const plcrash::CrashReport::SystemInfo&) systemInfo error: (NSError **) outError;
- (PLCrashReportProcessorInfo *) extractProcessorInfo: (const plcrash::CrashReport::Processor&) processorInfo error: (NSError **) outError;
- (PLCrashReportMachineInfo *) extractMachineInfo: (const plcrash::CrashReport::MachineInfo&) machineInfo error: (NSError **) outError;
- (PLCrashReportApplicationInfo *) extractApplicationInfo: (const plcrash::CrashReport::ApplicationInfo&) applicationInfo error: (NSError **) outError;
- (PLCrashReportProcessInfo *) extractProcessInfo: (const plcrash::CrashReport::ProcessInfo&) processInfo error: (NSError **) outError;
- (NSArray *) extractThreadInfo: (const plcrash::CrashReport&) crashReport error: (NSError **) outError;
- (NSArray *) extractImageInfo: (const plcrash::CrashReport&) crashReport error: (NSError **) outError;
- (PLCrashReportExceptionInfo *) extractExceptionInfo: (const plcrash::CrashReport::Exception&) exceptionInfo error: (NSError **) outError;
- (PLCrashReportSignalInfo *) extractSignalInfo: (const plcrash::CrashReport::Signal&) signalInfo error: (NSError **) outError;

@end


static void populate_nserror (NSError **error, PLCrashReporterError code, NSString *description);

/**
 * Provides decoding of crash logs generated by the PLCrashReporter framework.
 *
 * @warning This API should be considered in-development and subject to change.
 */
@implementation PLCrashReport

/**
 * Initialize with the provided crash log data. On error, nil will be returned, and
 * an NSError instance will be provided via @a error, if non-NULL.
 *
 * @param encodedData Encoded plcrash crash log.
 * @param outError If an error occurs, this pointer will contain an NSError object
 * indicating why the crash log could not be parsed. If no error occurs, this parameter
 * will be left unmodified. You may specify NULL for this parameter, and no error information
 * will be provided.
 *
 * @par Designated Initializer
 * This method is the designated initializer for the PLCrashReport class.
 */
- (id) initWithData: (NSData *) encodedData error: (NSError **) outError {
    if ((self = [super init]) == nil) {
        // This shouldn't happen, but we have to fufill our API contract
        populate_nserror(outError, PLCrashReporterErrorUnknown, @"Could not initialize superclass");
        return nil;
    }


    /* Allocate the struct and attempt to parse */
    _decoder = new _PLCrashReportDecoder;
    _decoder->crashReport = [self decodeCrashData: encodedData error: outError];

    /* Check if decoding failed. If so, outError has already been populated. */
    if (_decoder->crashReport == NULL) {
        goto error;
    }


    /* System info */
    if (!_decoder->crashReport->has_system_info()) {
      populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                       NSLocalizedString(@"Crash report is missing System Information section",
                                         @"Missing sysinfo in crash report"));
      goto error;
    }
    _systemInfo = [[self extractSystemInfo: _decoder->crashReport->system_info() error: outError] retain];
    if (!_systemInfo)
      goto error;

    /* Machine info */
    if (_decoder->crashReport->has_machine_info()) {
      _machineInfo = [[self extractMachineInfo: _decoder->crashReport->machine_info() error: outError] retain];
      if (!_machineInfo)
        goto error;
    }

    /* Application info */
    if (!_decoder->crashReport->has_application_info()) {
      populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                       NSLocalizedString(@"Crash report is missing Application Information section",
                                         @"Missing app info in crash report"));
      goto error;
    }
    _applicationInfo = [[self extractApplicationInfo: _decoder->crashReport->application_info() error: outError] retain];
    if (!_applicationInfo)
      goto error;

    /* Process info. Handle missing info gracefully -- it is only included in v1.1+ crash reports. */
    if (_decoder->crashReport->has_process_info()) {
      _processInfo = [[self extractProcessInfo: _decoder->crashReport->process_info() error:outError] retain];
        if (!_processInfo)
            goto error;
    }

    /* Signal info */
    _signalInfo = [[self extractSignalInfo: _decoder->crashReport->signal() error: outError] retain];
    if (!_signalInfo)
        goto error;

    /* Thread info */
    _threads = [[self extractThreadInfo: *_decoder->crashReport error: outError] retain];
    if (!_threads)
        goto error;

    /* Image info */
    _images = [[self extractImageInfo: *_decoder->crashReport error: outError] retain];
    if (!_images)
        goto error;

    /* Exception info, if it is available */
    if (_decoder->crashReport->has_exception()) {
      _exceptionInfo = [[self extractExceptionInfo: _decoder->crashReport->exception() error: outError] retain];
        if (!_exceptionInfo)
            goto error;
    }

    return self;

error:
    [self release];
    return nil;
}

- (void) dealloc {
    /* Free the data objects */
    [_systemInfo release];
    [_machineInfo release];
    [_applicationInfo release];
    [_processInfo release];
    [_signalInfo release];
    [_threads release];
    [_images release];
    [_exceptionInfo release];

    /* Free the decoder state */
    if (_decoder != NULL) {
        delete _decoder->crashReport;
        delete _decoder;
        _decoder = NULL;
    }

    [super dealloc];
}

/**
 * Return the binary image containing the given address, or nil if no binary image
 * is found.
 *
 * @param address The address to search for.
 */
- (PLCrashReportBinaryImageInfo *) imageForAddress: (uint64_t) address {
    for (PLCrashReportBinaryImageInfo *imageInfo in self.images) {
        if (imageInfo.imageBaseAddress <= address && address < (imageInfo.imageBaseAddress + imageInfo.imageSize))
            return imageInfo;
    }

    /* Not found */
    return nil;
}

// property getter. Returns YES if machine information is available.
- (BOOL) hasMachineInfo {
    if (_machineInfo != nil)
        return YES;
    return NO;
}

// property getter. Returns YES if process information is available.
- (BOOL) hasProcessInfo {
    if (_processInfo != nil)
        return YES;
    return NO;
}

// property getter. Returns YES if exception information is available.
- (BOOL) hasExceptionInfo {
    if (_exceptionInfo != nil)
        return YES;
    return NO;
}

@synthesize systemInfo = _systemInfo;
@synthesize machineInfo = _machineInfo;
@synthesize applicationInfo = _applicationInfo;
@synthesize processInfo = _processInfo;
@synthesize signalInfo = _signalInfo;
@synthesize threads = _threads;
@synthesize images = _images;
@synthesize exceptionInfo = _exceptionInfo;

@end


/**
 * @internal
 * Private Methods
 */
@implementation PLCrashReport (PrivateMethods)

/**
 * Decode the crash log message.
 *
 * @warning MEMORY WARNING. The caller is responsible for deallocating the plcrash::CrashReport instance
 * returned by this method via protobuf_c_message_free_unpacked().
 */
- (plcrash::CrashReport *) decodeCrashData: (NSData *) data error: (NSError **) outError {
    const struct PLCrashReportFileHeader *header;
    const void *bytes;

    bytes = [data bytes];
    header = (const struct PLCrashReportFileHeader*)bytes;

    /* Verify that the crash log is sufficently large */
    if (sizeof(struct PLCrashReportFileHeader) >= [data length]) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid, NSLocalizedString(@"Could not decode truncated crash log",
                                                                                             @"Crash log decoding error message"));
        return NULL;
    }

    /* Check the file magic */
    if (memcmp(header->magic, PLCRASH_REPORT_FILE_MAGIC, strlen(PLCRASH_REPORT_FILE_MAGIC)) != 0) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,NSLocalizedString(@"Could not decode invalid crash log header",
                                                                                            @"Crash log decoding error message"));
        return NULL;
    }

    /* Check the version */
    if(header->version != PLCRASH_REPORT_FILE_VERSION) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid, [NSString stringWithFormat: NSLocalizedString(@"Could not decode unsupported crash report version: %d",
                                                                                                                         @"Crash log decoding message"), header->version]);
        return NULL;
    }

    plcrash::CrashReport *crashReport = new plcrash::CrashReport;
    if (crashReport == NULL ||
        !crashReport->ParseFromArray(
            header->data, [data length] - sizeof(struct PLCrashReportFileHeader))) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid, NSLocalizedString(@"An unknown error occured decoding the crash report",
                                                                                             @"Crash log decoding error message"));
        delete crashReport;
        return NULL;
    }

    return crashReport;
}


/**
 * Extract system information from the crash log. Returns nil on error.
 */
- (PLCrashReportSystemInfo *) extractSystemInfo: (const plcrash::CrashReport::SystemInfo&) systemInfo error: (NSError **) outError {
    NSDate *timestamp = nil;
    NSString *osBuild = nil;

    /* Validate */
    if (!systemInfo.has_os_version()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing System Information OS version field",
                                           @"Missing sysinfo operating system in crash report"));
        return nil;
    }

    /* Set up the build, if available */
    if (systemInfo.has_os_build())
      osBuild = [NSString stringWithUTF8String: systemInfo.os_build().c_str()];

    /* Set up the timestamp, if available */
    if (systemInfo.timestamp() != 0)
      timestamp = [NSDate dateWithTimeIntervalSince1970: systemInfo.timestamp()];

    /* Done */
    return [[[PLCrashReportSystemInfo alloc] initWithOperatingSystem: (PLCrashReportOperatingSystem) systemInfo.operating_system()
                                              operatingSystemVersion: [NSString stringWithUTF8String: systemInfo.os_version().c_str()]
                                                operatingSystemBuild: osBuild
                                                        architecture: (PLCrashReportArchitecture) systemInfo.architecture()
                                                           timestamp: timestamp] autorelease];
}

/**
 * Extract processor information from the crash log. Returns nil on error.
 */
- (PLCrashReportProcessorInfo *) extractProcessorInfo: (const plcrash::CrashReport::Processor&) processorInfo error: (NSError **) outError {
  return [[[PLCrashReportProcessorInfo alloc] initWithTypeEncoding: (PLCrashReportProcessorTypeEncoding) processorInfo.encoding()
                                                              type: processorInfo.type()
                                                           subtype: processorInfo.subtype()] autorelease];
}

/**
 * Extract machine information from the crash log. Returns nil on error.
 */
- (PLCrashReportMachineInfo *) extractMachineInfo: (const plcrash::CrashReport::MachineInfo&) machineInfo error: (NSError **) outError {
    NSString *model = nil;
    PLCrashReportProcessorInfo *processorInfo = nil;

    /* Set up the model, if available */
    if (machineInfo.has_model())
      model = [NSString stringWithUTF8String: machineInfo.model().c_str()];

    /* Set up the processor info. */
    if (machineInfo.has_processor()) {
      processorInfo = [self extractProcessorInfo: machineInfo.processor() error: outError];
      if (processorInfo == nil)
        return nil;
    }

    /* Done */
    return [[[PLCrashReportMachineInfo alloc] initWithModelName: model
                                                  processorInfo: processorInfo
                                                 processorCount: machineInfo.processor_count()
                                          logicalProcessorCount: machineInfo.logical_processor_count()] autorelease];
}

/**
 * Extract application information from the crash log. Returns nil on error.
 */
- (PLCrashReportApplicationInfo *) extractApplicationInfo: (const plcrash::CrashReport::ApplicationInfo&) applicationInfo
                                                    error: (NSError **) outError
{
    /* Identifier available? */
    if (!applicationInfo.has_identifier()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing Application Information app identifier field",
                                           @"Missing app identifier in crash report"));
        return nil;
    }

    /* Version available? */
    if (!applicationInfo.has_version()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing Application Information app version field",
                                           @"Missing app version in crash report"));
        return nil;
    }

    /* Done */
    NSString *identifier = [NSString stringWithUTF8String: applicationInfo.identifier().c_str()];
    NSString *version = [NSString stringWithUTF8String: applicationInfo.version().c_str()];

    return [[[PLCrashReportApplicationInfo alloc] initWithApplicationIdentifier: identifier
                                                          applicationVersion: version] autorelease];
}


/**
 * Extract process information from the crash log. Returns nil on error.
 */
- (PLCrashReportProcessInfo *) extractProcessInfo: (const plcrash::CrashReport::ProcessInfo&) processInfo
                                            error: (NSError **) outError
{
    /* Name available? */
    NSString *processName = nil;
    if (processInfo.has_process_name())
      processName = [NSString stringWithUTF8String: processInfo.process_name().c_str()];

    /* Path available? */
    NSString *processPath = nil;
    if (processInfo.has_process_path())
      processPath = [NSString stringWithUTF8String: processInfo.process_path().c_str()];

    /* Parent Name available? */
    NSString *parentProcessName = nil;
    if (processInfo.has_parent_process_name())
      parentProcessName = [NSString stringWithUTF8String: processInfo.parent_process_name().c_str()];

    /* Required elements */
    NSUInteger processID = processInfo.process_id();
    NSUInteger parentProcessID = processInfo.parent_process_id();

    /* Done */
    return [[[PLCrashReportProcessInfo alloc] initWithProcessName: processName
                                                        processID: processID
                                                      processPath: processPath
                                                parentProcessName: parentProcessName
                                                  parentProcessID: parentProcessID
                                                           native: processInfo.native()] autorelease];
}

/**
 * Extract stack frame information from the crash log. Returns nil on error, or a PLCrashReportStackFrameInfo
 * instance on success.
 */
- (PLCrashReportStackFrameInfo *) extractStackFrameInfo: (const plcrash::CrashReport::Thread::StackFrame&) stackFrame error: (NSError **) outError {
    /* There should be at least one thread */
  return [[[PLCrashReportStackFrameInfo alloc] initWithInstructionPointer: stackFrame.pc()] autorelease];
}

/**
 * Extract thread information from the crash log. Returns nil on error, or an array of PLCrashLogThreadInfo
 * instances on success.
 */
- (NSArray *) extractThreadInfo: (const plcrash::CrashReport&) crashReport error: (NSError **) outError {
    /* There should be at least one thread */
    if (crashReport.threads_size() == 0) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing thread state information",
                                           @"Missing thread info in crash report"));
        return nil;
    }

    /* Handle all threads */
    NSMutableArray *threadResult = [NSMutableArray arrayWithCapacity: crashReport.threads_size()];
    for (size_t thr_idx = 0; thr_idx < crashReport.threads_size(); thr_idx++) {
        const plcrash::CrashReport::Thread& thread = crashReport.threads(thr_idx);

        /* Fetch stack frames for this thread */
        NSMutableArray *frames = [NSMutableArray arrayWithCapacity: thread.frames_size()];
        for (size_t frame_idx = 0; frame_idx < thread.frames_size(); frame_idx++) {
            const plcrash::CrashReport::Thread::StackFrame &frame = thread.frames(frame_idx);
            PLCrashReportStackFrameInfo *frameInfo = [self extractStackFrameInfo: frame error: outError];
            if (frameInfo == nil)
                return nil;

            [frames addObject: frameInfo];
        }

        /* Fetch registers for this thread */
        NSMutableArray *registers = [NSMutableArray arrayWithCapacity: thread.registers_size()];
        for (size_t reg_idx = 0; reg_idx < thread.registers_size(); reg_idx++) {
            const plcrash::CrashReport::Thread::RegisterValue &reg = thread.registers(reg_idx);
            PLCrashReportRegisterInfo *regInfo;

            /* Handle missing register name (should not occur!) */
            if (!reg.has_name()) {
                populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid, @"Missing register name in register value");
                return nil;
            }

            regInfo = [[[PLCrashReportRegisterInfo alloc] initWithRegisterName: [NSString stringWithUTF8String: reg.name().c_str()]
                                                                 registerValue: reg.value()] autorelease];
            [registers addObject: regInfo];
        }

        /* Create the thread info instance */
        PLCrashReportThreadInfo *threadInfo = [[[PLCrashReportThreadInfo alloc] initWithThreadNumber: thread.thread_number()
                                                                                   stackFrames: frames
                                                                                             crashed: thread.crashed()
                                                                                     registers: registers] autorelease];
        [threadResult addObject: threadInfo];
    }

    return threadResult;
}


/**
 * Extract binary image information from the crash log. Returns nil on error.
 */
- (NSArray *) extractImageInfo: (const plcrash::CrashReport&) crashReport error: (NSError **) outError {
    /* There should be at least one image */
    if (crashReport.binary_images_size() == 0) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing binary image information",
                                           @"Missing image info in crash report"));
        return nil;
    }

    /* Handle all records */
    NSMutableArray *images = [NSMutableArray arrayWithCapacity: crashReport.binary_images_size()];
    for (size_t i = 0; i < crashReport.binary_images_size(); i++) {
        const plcrash::CrashReport::BinaryImage &image = crashReport.binary_images(i);
        PLCrashReportBinaryImageInfo *imageInfo;

        /* Validate */
        if (!image.has_name()) {
            populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid, @"Missing image name in image record");
            return nil;
        }

        /* Extract UUID value */
        NSData *uuid = nil;
        if (image.uuid().empty()) {
            /* No UUID */
            uuid = nil;
        } else {
            uuid = [NSData dataWithBytes: image.uuid().data() length: image.uuid().size()];
        }
        assert(image.uuid().size() == 0 || uuid != nil);

        /* Extract code type (if available). */
        PLCrashReportProcessorInfo *codeType = nil;
        if (image.has_code_type()) {
            if ((codeType = [self extractProcessorInfo: image.code_type() error: outError]) == nil)
                return nil;
        }


        imageInfo = [[[PLCrashReportBinaryImageInfo alloc] initWithCodeType: codeType
                                                                baseAddress: image.base_address()
                                                                       size: image.size()
                                                                       name: [NSString stringWithUTF8String: image.name().c_str()]
                                                                       uuid: uuid] autorelease];
        [images addObject: imageInfo];
    }

    return images;
}

/**
 * Extract  exception information from the crash log. Returns nil on error.
 */
- (PLCrashReportExceptionInfo *) extractExceptionInfo: (const plcrash::CrashReport::Exception&) exceptionInfo
                                                error: (NSError **) outError
{
    /* Name available? */
    if (!exceptionInfo.has_name()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing exception name field",
                                           @"Missing appinfo operating system in crash report"));
        return nil;
    }

    /* Reason available? */
    if (!exceptionInfo.has_reason()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing exception reason field",
                                           @"Missing appinfo operating system in crash report"));
        return nil;
    }

    /* Done */
    NSString *name = [NSString stringWithUTF8String: exceptionInfo.name().c_str()];
    NSString *reason = [NSString stringWithUTF8String: exceptionInfo.reason().c_str()];

    /* Fetch stack frames for this thread */
    NSMutableArray *frames = nil;
    if (exceptionInfo.frames_size() > 0) {
        frames = [NSMutableArray arrayWithCapacity: exceptionInfo.frames_size()];
        for (size_t frame_idx = 0; frame_idx < exceptionInfo.frames_size(); frame_idx++) {
            const plcrash::CrashReport::Thread::StackFrame &frame = exceptionInfo.frames(frame_idx);
            PLCrashReportStackFrameInfo *frameInfo = [self extractStackFrameInfo: frame error: outError];
            if (frameInfo == nil)
                return nil;

            [frames addObject: frameInfo];
        }
    }

    if (frames == nil) {
        return [[[PLCrashReportExceptionInfo alloc] initWithExceptionName: name reason: reason] autorelease];
    } else {
        return [[[PLCrashReportExceptionInfo alloc] initWithExceptionName: name
                                                                   reason: reason
                                                              stackFrames: frames] autorelease];
    }
}

/**
 * Extract signal information from the crash log. Returns nil on error.
 */
- (PLCrashReportSignalInfo *) extractSignalInfo: (const plcrash::CrashReport::Signal&) signalInfo
                                          error: (NSError **) outError
{
    /* Name available? */
    if (!signalInfo.has_name()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing signal name field",
                                           @"Missing appinfo operating system in crash report"));
        return nil;
    }

    /* Code available? */
    if (!signalInfo.has_code()) {
        populate_nserror(outError, PLCrashReporterErrorCrashReportInvalid,
                         NSLocalizedString(@"Crash report is missing signal code field",
                                           @"Missing appinfo operating system in crash report"));
        return nil;
    }

    /* Done */
    NSString *name = [NSString stringWithUTF8String: signalInfo.name().c_str()];
    NSString *code = [NSString stringWithUTF8String: signalInfo.code().c_str()];

    return [[[PLCrashReportSignalInfo alloc] initWithSignalName: name code: code address: signalInfo.address()] autorelease];
}

@end

/**
 * @internal

 * Populate an NSError instance with the provided information.
 *
 * @param error Error instance to populate. If NULL, this method returns
 * and nothing is modified.
 * @param code The error code corresponding to this error.
 * @param description A localized error description.
 * @param cause The underlying cause, if any. May be nil.
 */
static void populate_nserror (NSError **error, PLCrashReporterError code, NSString *description) {
    NSMutableDictionary *userInfo;

    if (error == NULL)
        return;

    /* Create the userInfo dictionary */
    userInfo = [NSDictionary dictionaryWithObjectsAndKeys:
                description, NSLocalizedDescriptionKey,
                nil
                ];

    *error = [NSError errorWithDomain: PLCrashReporterErrorDomain code: code userInfo: userInfo];
}
